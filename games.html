<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ Chess Mini Games - Play & Learn!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            touch-action: manipulation;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5em;
            color: #4a5568;
            margin-bottom: 10px;
        }

        .back-btn {
            background: linear-gradient(45deg, #ff6b6b, #ffd93d);
            border: none;
            padding: 12px 20px;
            border-radius: 30px;
            color: white;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            margin-bottom: 15px;
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .game-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
        }

        .game-card:hover {
            transform: translateY(-5px);
            border-color: #74b9ff;
        }

        .game-icon {
            font-size: 3em;
            text-align: center;
            margin-bottom: 10px;
        }

        .game-title {
            font-size: 1.5em;
            color: #2d3436;
            margin-bottom: 8px;
            text-align: center;
            font-weight: bold;
        }

        .game-description {
            color: #636e72;
            text-align: center;
            margin-bottom: 12px;
            font-size: 0.9em;
        }

        .difficulty-badge {
            background: linear-gradient(45deg, #74b9ff, #0984e3);
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: bold;
            display: block;
            text-align: center;
            margin: 8px auto;
            width: fit-content;
        }

        .play-btn {
            background: linear-gradient(45deg, #00b894, #00cec9);
            border: none;
            padding: 12px 25px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            font-size: 14px;
            margin-top: 10px;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            display: none;
        }

        .game-container.active {
            display: block;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .game-stats {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .stat {
            background: linear-gradient(135deg, #ffeaa7, #fab1a0);
            padding: 10px 15px;
            border-radius: 10px;
            text-align: center;
            min-width: 80px;
        }

        .stat-label {
            font-size: 0.8em;
            color: #2d3436;
            font-weight: bold;
        }

        .stat-value {
            font-size: 1.2em;
            color: #e17055;
            font-weight: bold;
        }

        .instructions {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            text-align: center;
        }

        .difficulty-selector {
            background: linear-gradient(135deg, #fd79a8, #e84393);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            text-align: center;
        }

        .difficulty-options {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .difficulty-option {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid transparent;
            border-radius: 12px;
            padding: 15px 20px;
            cursor: pointer;
            font-weight: bold;
            min-width: 120px;
            transition: all 0.3s ease;
        }

        .difficulty-option:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .difficulty-option.selected {
            background: rgba(255, 255, 255, 0.4);
            border-color: #fff;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            margin: 20px auto;
            background: #8b4513;
            border-radius: 10px;
            padding: 10px;
            max-width: 400px;
            aspect-ratio: 1;
        }

        .game-square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            cursor: pointer;
            border-radius: 4px;
            aspect-ratio: 1;
            transition: all 0.2s ease;
        }

        .game-square.white {
            background: #f0d9b5;
        }

        .game-square.black {
            background: #b58863;
        }

        .game-square:hover {
            transform: scale(1.1);
            z-index: 10;
        }

        .game-square.selected {
            border: 4px solid #ff6b6b;
        }

        .game-square.valid-move {
            background: rgba(76, 175, 80, 0.4) !important;
        }

        .game-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .control-btn {
            background: linear-gradient(45deg, #e91e63, #f06292);
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 14px;
        }

        .game-status {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: center;
            font-weight: bold;
            font-size: 16px;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            font-weight: bold;
            border: 2px solid #28a745;
            display: none;
        }

        .success-message.show {
            display: block;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 5px;
            }

            .header h1 {
                font-size: 2em;
            }

            .games-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .game-board {
                max-width: 320px;
                padding: 8px;
            }

            .game-square {
                font-size: 24px;
            }

            .game-header {
                flex-direction: column;
                text-align: center;
            }

            .difficulty-options {
                gap: 10px;
            }

            .difficulty-option {
                min-width: 100px;
                padding: 12px 15px;
                font-size: 13px;
            }
        }

        @media (max-width: 480px) {
            .game-board {
                max-width: 280px;
                padding: 6px;
            }

            .game-square {
                font-size: 20px;
            }

            .difficulty-option {
                min-width: 80px;
                padding: 10px 12px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <button class="back-btn" onclick="goBack()">‚¨ÖÔ∏è Back to Chess Kingdom</button>
        
        <div class="header">
            <h1>üéÆ Chess Mini Games!</h1>
            <p>Play fun games and sharpen your chess skills!</p>
        </div>

        <!-- Games Grid -->
        <div class="games-grid" id="gamesGrid">
            <div class="game-card" onclick="startGame('piece-placement')">
                <div class="game-icon">üè∞</div>
                <div class="game-title">Piece Placement</div>
                <div class="game-description">Set up chess pieces in their starting positions!</div>
                <div class="difficulty-badge">‚≠ê Easy</div>
                <button class="play-btn">Play Now!</button>
            </div>

            <div class="game-card" onclick="startGame('knight-tour')">
                <div class="game-icon">‚ôû</div>
                <div class="game-title">Knight's Adventure</div>
                <div class="game-description">Move your knight to visit every square!</div>
                <div class="difficulty-badge">‚≠ê‚≠ê‚≠ê Hard</div>
                <button class="play-btn">Play Now!</button>
            </div>

            <div class="game-card" onclick="startGame('player-vs-computer')">
                <div class="game-icon">ü§ñ</div>
                <div class="game-title">Player vs Computer</div>
                <div class="game-description">Play real chess against the computer!</div>
                <div class="difficulty-badge">‚≠ê-‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê All Levels</div>
                <button class="play-btn">Play Now!</button>
            </div>

            <div class="game-card" onclick="startGame('checkmate-puzzles')">
                <div class="game-icon">üß©</div>
                <div class="game-title">Checkmate Puzzles</div>
                <div class="game-description">Find the best moves to deliver checkmate!</div>
                <div class="difficulty-badge">‚≠ê-‚≠ê‚≠ê‚≠ê All Levels</div>
                <button class="play-btn">Play Now!</button>
            </div>

            <div class="game-card" onclick="startGame('memory-match')">
                <div class="game-icon">üß†</div>
                <div class="game-title">Chess Memory</div>
                <div class="game-description">Match pairs of chess pieces!</div>
                <div class="difficulty-badge">‚≠ê‚≠ê Medium</div>
                <button class="play-btn">Play Now!</button>
            </div>
        </div>

        <!-- Game Container -->
        <div class="game-container" id="gameContainer">
            <div class="game-header">
                <div>
                    <h2 id="gameTitle">üéÆ Game</h2>
                    <button class="control-btn" onclick="backToMenu()">üè† Back to Games</button>
                </div>
                <div class="game-stats">
                    <div class="stat">
                        <div class="stat-label">Score</div>
                        <div class="stat-value" id="score">0</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">Time</div>
                        <div class="stat-value" id="time">00:00</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">Moves</div>
                        <div class="stat-value" id="moves">0</div>
                    </div>
                </div>
            </div>

            <div class="instructions" id="instructions">
                <h3>üéØ How to Play</h3>
                <p id="instructionsText">Select a game to see instructions!</p>
            </div>

            <!-- Difficulty Selector -->
            <div class="difficulty-selector" id="difficultySelector" style="display: none;">
                <h3>Choose Your Difficulty Level:</h3>
                <div class="difficulty-options" id="difficultyOptions"></div>
                <p id="difficultyDesc">Select a level to start playing!</p>
            </div>

            <!-- Game Status -->
            <div class="game-status" id="gameStatus" style="display: none;">
                <span id="statusText">Game Status</span>
            </div>

            <!-- Game Board -->
            <div class="game-board" id="gameBoard"></div>

            <!-- Controls -->
            <div class="game-controls">
                <button class="control-btn" onclick="resetCurrentGame()">üîÑ Reset</button>
                <button class="control-btn" onclick="showHint()" id="hintBtn">üí° Hint</button>
                <button class="control-btn" onclick="nextPuzzle()" id="nextBtn" style="display: none;">‚û°Ô∏è Next</button>
            </div>

            <div class="success-message" id="successMessage">
                üéâ Congratulations! You completed the challenge!
            </div>
        </div>
    </div>

    <script>
        // Global game state
        let currentGame = null;
        let gameState = {};
        let gameStats = { score: 0, time: 0, moves: 0 };
        let timer = null;
        let startTime = null;

        // Utility functions
        function goBack() {
            window.history.back();
        }

        function startGame(gameType) {
            currentGame = gameType;
            document.getElementById('gamesGrid').style.display = 'none';
            document.getElementById('gameContainer').classList.add('active');
            
            // Update title and instructions
            const titles = {
                'piece-placement': 'üè∞ Piece Placement',
                'knight-tour': '‚ôû Knight Adventure',
                'player-vs-computer': 'ü§ñ Player vs Computer',
                'checkmate-puzzles': 'üß© Checkmate Puzzles',
                'memory-match': 'üß† Chess Memory'
            };
            
            const instructions = {
                'piece-placement': 'Click on empty squares to place chess pieces in their correct starting positions!',
                'knight-tour': 'Click on squares to move your knight! Visit every square exactly once. Knights move in L-shape!',
                'player-vs-computer': 'Play real chess! Click your pieces then click where to move them.',
                'checkmate-puzzles': 'Find the best moves to deliver checkmate! Study the position carefully.',
                'memory-match': 'Click cards to flip them and find matching pairs of chess pieces!'
            };
            
            document.getElementById('gameTitle').textContent = titles[gameType];
            document.getElementById('instructionsText').textContent = instructions[gameType];
            
            // Reset stats
            resetStats();
            
            // Show difficulty selector for specific games
            if (gameType === 'player-vs-computer' || gameType === 'checkmate-puzzles') {
                showDifficultySelector(gameType);
            } else {
                document.getElementById('difficultySelector').style.display = 'none';
                setupGame(gameType);
            }
        }

        function showDifficultySelector(gameType) {
            const selector = document.getElementById('difficultySelector');
            const options = document.getElementById('difficultyOptions');
            
            selector.style.display = 'block';
            options.innerHTML = '';
            
            let difficulties = [];
            if (gameType === 'player-vs-computer') {
                difficulties = [
                    { id: 'beginner', name: 'Beginner', desc: 'Computer makes random moves' },
                    { id: 'easy', name: 'Easy', desc: 'Computer plays basic moves' },
                    { id: 'medium', name: 'Medium', desc: 'Computer thinks strategically' },
                    { id: 'hard', name: 'Hard', desc: 'Computer plays expertly' },
                    { id: 'master', name: 'Master', desc: 'Computer plays perfectly' }
                ];
            } else {
                difficulties = [
                    { id: 'easy', name: 'Easy', desc: 'Mate in 1-2 moves' },
                    { id: 'medium', name: 'Medium', desc: 'Mate in 2-3 moves' },
                    { id: 'hard', name: 'Hard', desc: 'Mate in 3+ moves' }
                ];
            }
            
            difficulties.forEach(diff => {
                const option = document.createElement('div');
                option.className = 'difficulty-option';
                option.textContent = diff.name;
                option.onclick = () => selectDifficulty(diff, gameType);
                options.appendChild(option);
            });
        }

        function selectDifficulty(difficulty, gameType) {
            document.querySelectorAll('.difficulty-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            event.target.classList.add('selected');
            
            document.getElementById('difficultyDesc').textContent = difficulty.desc;
            
            setTimeout(() => {
                document.getElementById('difficultySelector').style.display = 'none';
                gameState.difficulty = difficulty.id;
                setupGame(gameType);
                showMessage(`üéÆ ${difficulty.name} level started!`);
            }, 1000);
        }

        function setupGame(gameType) {
            document.getElementById('gameStatus').style.display = 'none';
            document.getElementById('nextBtn').style.display = 'none';
            
            switch (gameType) {
                case 'piece-placement':
                    setupPiecePlacement();
                    break;
                case 'knight-tour':
                    setupKnightTour();
                    break;
                case 'player-vs-computer':
                    setupPlayerVsComputer();
                    break;
                case 'checkmate-puzzles':
                    setupCheckmatePuzzles();
                    break;
                case 'memory-match':
                    setupMemoryMatch();
                    break;
            }
            
            startTimer();
        }

        function createBoard() {
            const board = document.getElementById('gameBoard');
            board.innerHTML = '';
            
            for (let row = 7; row >= 0; row--) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `game-square ${(row + col) % 2 === 0 ? 'black' : 'white'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    board.appendChild(square);
                }
            }
        }

        // Piece Placement Game
        function setupPiecePlacement() {
            createBoard();
            gameState = {
                pieces: ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'],
                placed: {},
                currentPiece: 0
            };
            
            document.querySelectorAll('.game-square').forEach(square => {
                if (square.dataset.row === '0') {
                    square.onclick = () => placePiece(square);
                }
            });
            
            updatePiecePlacement();
        }

        function placePiece(square) {
            if (gameState.currentPiece >= gameState.pieces.length) return;
            
            const piece = gameState.pieces[gameState.currentPiece];
            const col = parseInt(square.dataset.col);
            
            square.textContent = piece;
            square.style.color = '#2c3e50';
            gameState.placed[col] = piece;
            gameState.currentPiece++;
            gameStats.moves++;
            gameStats.score += 10;
            
            updateStats();
            
            if (gameState.currentPiece >= gameState.pieces.length) {
                checkPiecePlacement();
            } else {
                updatePiecePlacement();
            }
        }

        function updatePiecePlacement() {
            if (gameState.currentPiece < gameState.pieces.length) {
                const piece = gameState.pieces[gameState.currentPiece];
                updateStatus(`Place the ${piece} piece on the board!`);
            }
        }

        function checkPiecePlacement() {
            const correct = ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'];
            let score = 0;
            
            for (let i = 0; i < 8; i++) {
                if (gameState.placed[i] === correct[i]) {
                    score += 10;
                }
            }
            
            gameStats.score = score;
            updateStats();
            
            if (score === 80) {
                showSuccess('Perfect placement! All pieces correct!');
            } else {
                showSuccess(`Good job! You got ${score/10} out of 8 pieces correct!`);
            }
        }

        // Knight Tour Game
        function setupKnightTour() {
            createBoard();
            gameState = {
                knightPos: { row: 0, col: 0 },
                visited: new Set(['0-0']),
                moveCount: 1
            };
            
            const startSquare = document.querySelector('[data-row="0"][data-col="0"]');
            startSquare.textContent = '‚ôû';
            startSquare.style.color = '#2c3e50';
            
            document.querySelectorAll('.game-square').forEach(square => {
                square.onclick = () => moveKnight(square);
            });
            
            updateStatus(`Move ${gameState.moveCount}/64 - Click to move your knight!`);
        }

        function moveKnight(square) {
            const newRow = parseInt(square.dataset.row);
            const newCol = parseInt(square.dataset.col);
            const { row: oldRow, col: oldCol } = gameState.knightPos;
            
            // Check valid knight move
            const rowDiff = Math.abs(newRow - oldRow);
            const colDiff = Math.abs(newCol - oldCol);
            
            if (!((rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2))) {
                showMessage('‚ùå Invalid knight move! Knights move in L-shape.');
                return;
            }
            
            const key = `${newRow}-${newCol}`;
            if (gameState.visited.has(key)) {
                showMessage('‚ùå Already visited this square!');
                return;
            }
            
            // Make the move
            const oldSquare = document.querySelector(`[data-row="${oldRow}"][data-col="${oldCol}"]`);
            oldSquare.textContent = gameState.moveCount.toString();
            oldSquare.style.color = '#7f8c8d';
            
            square.textContent = '‚ôû';
            square.style.color = '#2c3e50';
            
            gameState.knightPos = { row: newRow, col: newCol };
            gameState.visited.add(key);
            gameState.moveCount++;
            gameStats.moves++;
            gameStats.score += 5;
            
            updateStats();
            
            if (gameState.visited.size === 64) {
                showSuccess('Amazing! You completed the Knight\'s Tour!');
            } else {
                updateStatus(`Move ${gameState.moveCount}/64 - Keep going!`);
            }
        }

        // Player vs Computer Chess
        function setupPlayerVsComputer() {
            createBoard();
            gameState = {
                board: createChessBoard(),
                currentPlayer: 'white',
                selectedSquare: null,
                gameOver: false
            };
            
            renderChessBoard();
            updateStatus('Your turn! Click a white piece to move.');
            document.getElementById('gameStatus').style.display = 'block';
        }

        function createChessBoard() {
            const board = Array(8).fill().map(() => Array(8).fill(null));
            
            // Setup pieces
            const pieces = {
                0: ['‚ôú','‚ôû','‚ôù','‚ôõ','‚ôö','‚ôù','‚ôû','‚ôú'],
                1: Array(8).fill('‚ôü'),
                6: Array(8).fill('‚ôô'),
                7: ['‚ôñ','‚ôò','‚ôó','‚ôï','‚ôî','‚ôó','‚ôò','‚ôñ']
            };
            
            Object.entries(pieces).forEach(([row, rowPieces]) => {
                rowPieces.forEach((piece, col) => {
                    board[row][col] = {
                        piece: piece,
                        color: parseInt(row) < 2 ? 'black' : 'white'
                    };
                });
            });
            
            return board;
        }

        function renderChessBoard() {
            document.querySelectorAll('.game-square').forEach((square, index) => {
                const row = 7 - Math.floor(index / 8);
                const col = index % 8;
                const piece = gameState.board[row][col];
                
                square.textContent = piece ? piece.piece : '';
                square.style.color = piece && piece.color === 'white' ? '#2980b9' : '#e74c3c';
                square.classList.remove('selected', 'valid-move');
                square.onclick = () => handleChessClick(square, row, col);
            });
        }

        function handleChessClick(square, row, col) {
            if (gameState.gameOver || gameState.currentPlayer !== 'white') return;
            
            const piece = gameState.board[row][col];
            
            if (gameState.selectedSquare) {
                if (isValidChessMove(gameState.selectedSquare, { row, col })) {
                    makeChessMove(gameState.selectedSquare, { row, col });
                    clearSelection();
                    
                    setTimeout(() => {
                        if (!gameState.gameOver) makeComputerMove();
                    }, 1000);
                } else {
                    clearSelection();
                    if (piece && piece.color === 'white') {
                        selectSquare(square, row, col);
                    }
                }
            } else if (piece && piece.color === 'white') {
                selectSquare(square, row, col);
            }
        }

        function selectSquare(square, row, col) {
            gameState.selectedSquare = { row, col };
            square.classList.add('selected');
            
            // Highlight valid moves
            document.querySelectorAll('.game-square').forEach((sq, index) => {
                const r = 7 - Math.floor(index / 8);
                const c = index % 8;
                if (isValidChessMove({ row, col }, { row: r, col: c })) {
                    sq.classList.add('valid-move');
                }
            });
        }

        function clearSelection() {
            document.querySelectorAll('.game-square').forEach(sq => {
                sq.classList.remove('selected', 'valid-move');
            });
            gameState.selectedSquare = null;
        }

        function isValidChessMove(from, to) {
            const piece = gameState.board[from.row][from.col];
            const target = gameState.board[to.row][to.col];
            
            if (!piece || (target && target.color === piece.color)) return false;
            if (from.row === to.row && from.col === to.col) return false;
            
            // Simplified move validation
            return true; // For demo purposes, allow all moves
        }

        function makeChessMove(from, to) {
            const piece = gameState.board[from.row][from.col];
            const captured = gameState.board[to.row][to.col];
            
            gameState.board[to.row][to.col] = piece;
            gameState.board[from.row][from.col] = null;
            
            gameStats.moves++;
            updateStats();
            
            // Check for king capture
            if (captured && (captured.piece === '‚ôî' || captured.piece === '‚ôö')) {
                gameState.gameOver = true;
                showSuccess(gameState.currentPlayer === 'white' ? 'You won!' : 'Computer won!');
                return;
            }
            
            gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
            renderChessBoard();
            
            if (gameState.currentPlayer === 'white') {
                updateStatus('Your turn!');
            } else {
                updateStatus('Computer is thinking...');
            }
        }

        function makeComputerMove() {
            if (gameState.gameOver) return;
            
            const moves = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.color === 'black') {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidChessMove({row, col}, {row: toRow, col: toCol})) {
                                    moves.push({from: {row, col}, to: {row: toRow, col: toCol}});
                                }
                            }
                        }
                    }
                }
            }
            
            if (moves.length > 0) {
                const randomMove = moves[Math.floor(Math.random() * moves.length)];
                makeChessMove(randomMove.from, randomMove.to);
            }
        }

        // Checkmate Puzzles
        function setupCheckmatePuzzles() {
            createBoard();
            
            const puzzles = {
                easy: [
                    {
                        position: [
                            [null, null, null, null, null, {piece: '‚ôö', color: 'black'}, null, null],
                            [null, null, null, null, null, {piece: '‚ôü', color: 'black'}, {piece: '‚ôü', color: 'black'}, null],
                            [null, null, null, null, null, null, null, null],
                            [null, null, null, null, null, null, null, null],
                            [null, null, null, null, null, null, null, null],
                            [null, null, null, null, null, null, null, null],
                            [null, null, null, null, null, null, null, null],
                            [{piece: '‚ôñ', color: 'white'}, null, null, null, null, null, null, null]
                        ],
                        solution: {from: {row: 0, col: 0}, to: {row: 7, col: 0}},
                        description: 'Back rank mate! Move your rook.'
                    }
                ],
                medium: [
                    {
                        position: [
                            [null, null, null, null, null, null, {piece: '‚ôö', color: 'black'}, null],
                            [null, null, null, null, null, {piece: '‚ôü', color: 'black'}, {piece: '‚ôü', color: 'black'}, {piece: '‚ôü', color: 'black'}],
                            [null, null, null, null, null, null, null, null],
                            [null, null, null, null, null, null, null, null],
                            [null, null, null, null, null, null, null, null],
                            [null, null, null, null, null, null, null, null],
                            [null, null, null, null, null, null, null, null],
                            [null, null, null, {piece: '‚ôï', color: 'white'}, null, null, null, {piece: '‚ôñ', color: 'white'}]
                        ],
                        solution: {from: {row: 0, col: 3}, to: {row: 7, col: 3}},
                        description: 'Queen delivers checkmate!'
                    }
                ],
                hard: [
                    {
                        position: [
                            [{piece: '‚ôú', color: 'black'}, null, null, null, null, null, {piece: '‚ôö', color: 'black'}, null],
                            [{piece: '‚ôü', color: 'black'}, {piece: '‚ôü', color: 'black'}, null, null, null, {piece: '‚ôü', color: 'black'}, {piece: '‚ôü', color: 'black'}, {piece: '‚ôü', color: 'black'}],
                            [null, null, null, null, null, null, null, null],
                            [null, null, null, null, null, null, null, null],
                            [null, null, null, null, null, null, null, null],
                            [null, null, null, null, null, null, null, null],
                            [null, null, null, null, null, null, null, null],
                            [null, null, null, {piece: '‚ôï', color: 'white'}, null, null, null, {piece: '‚ôñ', color: 'white'}]
                        ],
                        solution: {from: {row: 0, col: 3}, to: {row: 7, col: 3}},
                        description: 'Complex mating attack!'
                    }
                ]
            };
            
            const difficulty = gameState.difficulty || 'easy';
            const puzzleSet = puzzles[difficulty];
            const puzzle = puzzleSet[Math.floor(Math.random() * puzzleSet.length)];
            
            gameState = {
                ...gameState,
                board: puzzle.position,
                solution: puzzle.solution,
                completed: false,
                description: puzzle.description
            };
            
            renderChessBoard();
            updateStatus(puzzle.description);
            document.getElementById('nextBtn').style.display = 'inline-block';
            
            document.querySelectorAll('.game-square').forEach((square, index) => {
                const row = 7 - Math.floor(index / 8);
                const col = index % 8;
                square.onclick = () => handlePuzzleClick(square, row, col);
            });
        }

        function handlePuzzleClick(square, row, col) {
            if (gameState.completed) return;
            
            const piece = gameState.board[row][col];
            
            if (gameState.selectedSquare) {
                const move = {from: gameState.selectedSquare, to: {row, col}};
                
                if (move.from.row === gameState.solution.from.row && 
                    move.from.col === gameState.solution.from.col &&
                    move.to.row === gameState.solution.to.row && 
                    move.to.col === gameState.solution.to.col) {
                    
                    // Correct solution!
                    makeChessMove(move.from, move.to);
                    gameState.completed = true;
                    gameStats.score += 50;
                    updateStats();
                    showSuccess('Perfect! You found the checkmate!');
                } else {
                    showMessage('‚ùå Not the best move. Try again!');
                }
                
                clearSelection();
            } else if (piece && piece.color === 'white') {
                selectSquare(square, row, col);
            }
        }

        function nextPuzzle() {
            if (currentGame === 'checkmate-puzzles') {
                setupCheckmatePuzzles();
                showMessage('üß© New puzzle loaded!');
            }
        }

        // Memory Match Game
        function setupMemoryMatch() {
            const board = document.getElementById('gameBoard');
            board.innerHTML = '';
            board.style.gridTemplateColumns = 'repeat(4, 1fr)';
            board.style.gridTemplateRows = 'repeat(4, 1fr)';
            
            const pieces = ['‚ôî', '‚ôï', '‚ôñ', '‚ôó', '‚ôò', '‚ôô', '‚ôö', '‚ôõ'];
            const cards = [...pieces, ...pieces];
            
            // Shuffle cards
            for (let i = cards.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [cards[i], cards[j]] = [cards[j], cards[i]];
            }
            
            gameState = {
                cards: cards,
                flipped: [],
                matched: [],
                canFlip: true
            };
            
            cards.forEach((piece, index) => {
                const card = document.createElement('div');
                card.className = 'game-square';
                card.style.background = 'linear-gradient(135deg, #74b9ff, #0984e3)';
                card.style.color = 'white';
                card.style.fontSize = '32px';
                card.style.fontWeight = 'bold';
                card.textContent = '?';
                card.onclick = () => flipCard(index, card, piece);
                board.appendChild(card);
            });
        }

        function flipCard(index, cardElement, piece) {
            if (!gameState.canFlip || gameState.flipped.includes(index) || gameState.matched.includes(index)) {
                return;
            }
            
            cardElement.textContent = piece;
            cardElement.style.background = 'linear-gradient(135deg, #00b894, #00cec9)';
            gameState.flipped.push(index);
            
            if (gameState.flipped.length === 2) {
                gameState.canFlip = false;
                gameStats.moves++;
                updateStats();
                
                setTimeout(() => {
                    checkMemoryMatch();
                }, 1000);
            }
        }

        function checkMemoryMatch() {
            const [index1, index2] = gameState.flipped;
            const piece1 = gameState.cards[index1];
            const piece2 = gameState.cards[index2];
            
            if (piece1 === piece2) {
                // Match found!
                gameState.matched.push(index1, index2);
                gameStats.score += 20;
                updateStats();
                showMessage('‚úÖ Match found!');
                
                if (gameState.matched.length === 16) {
                    showSuccess('üß† Perfect memory! All pairs matched!');
                }
            } else {
                // No match - flip back
                const cards = document.querySelectorAll('.game-square');
                cards[index1].textContent = '?';
                cards[index1].style.background = 'linear-gradient(135deg, #74b9ff, #0984e3)';
                cards[index2].textContent = '?';
                cards[index2].style.background = 'linear-gradient(135deg, #74b9ff, #0984e3)';
                showMessage('‚ùå No match - try again!');
            }
            
            gameState.flipped = [];
            gameState.canFlip = true;
        }

        // Utility functions
        function backToMenu() {
            stopTimer();
            document.getElementById('gameContainer').classList.remove('active');
            document.getElementById('gamesGrid').style.display = 'grid';
            currentGame = null;
            resetStats();
        }

        function resetCurrentGame() {
            if (currentGame) {
                stopTimer();
                resetStats();
                setupGame(currentGame);
            }
        }

        function startTimer() {
            startTime = Date.now();
            timer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('time').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                gameStats.time = elapsed;
            }, 1000);
        }

        function stopTimer() {
            if (timer) {
                clearInterval(timer);
                timer = null;
            }
        }

        function resetStats() {
            gameStats = { score: 0, time: 0, moves: 0 };
            updateStats();
        }

        function updateStats() {
            document.getElementById('score').textContent = gameStats.score;
            document.getElementById('moves').textContent = gameStats.moves;
        }

        function updateStatus(message) {
            document.getElementById('statusText').textContent = message;
            document.getElementById('gameStatus').style.display = 'block';
        }

        function showMessage(message) {
            // Simple alert for now - could be enhanced with better UI
            updateStatus(message);
        }

        function showSuccess(message) {
            stopTimer();
            document.getElementById('successMessage').textContent = message;
            document.getElementById('successMessage').classList.add('show');
            updateStatus(message);
        }

        function showHint() {
            const hints = {
                'piece-placement': 'Remember the starting setup: Rook, Knight, Bishop, Queen, King, Bishop, Knight, Rook',
                'knight-tour': 'Knights move in an L-shape: 2 squares in one direction, then 1 square perpendicular',
                'player-vs-computer': 'Look for pieces you can capture or moves that protect your king',
                'checkmate-puzzles': 'Look for forcing moves that attack the enemy king',
                'memory-match': 'Try to remember the positions of pieces you\'ve already seen'
            };
            
            if (currentGame && hints[currentGame]) {
                showMessage('üí° ' + hints[currentGame]);
                gameStats.score = Math.max(0, gameStats.score - 5);
                updateStats();
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            resetStats();
        });
    </script>
</body>
</html>